package org.by1337.bpatcher.util.clazz.write;

import org.by1337.bpatcher.util.clazz.ClassData;
import org.by1337.bpatcher.util.clazz.ClassFinder;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Type;

public class CustomClassWriter extends ClassWriter {
    private final ClassFinder classFinder;

    /**
     * Constructs a new {@link ClassWriter} object.
     *
     * @param flags option flags that can be used to modify the default behavior of this class. Must
     *              be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.
     */
    public CustomClassWriter(int flags, ClassFinder classFinder) {
        super(flags);
        this.classFinder = classFinder;
    }

    /**
     * Returns the common super type of the two given types. The default implementation of this method
     * <i>loads</i> the two given classes and uses the java.lang.Class methods to find the common
     * super class. It can be overridden to compute this common super type in other ways, in
     * particular without actually loading any class, or to take into account the class that is
     * currently being generated by this ClassWriter, which can of course not be loaded since it is
     * under construction.
     *
     * @param type1 the internal name of a class (see {@link Type#getInternalName()}).
     * @param type2 the internal name of another class (see {@link Type#getInternalName()}).
     * @return the internal name of the common super class of the two given classes (see {@link
     * Type#getInternalName()}).
     */
    @Override
    protected String getCommonSuperClass(String type1, String type2) {

        ClassData class1 = classFinder.findClass(type1);
        if (class1 == null) {
            throw new TypeNotPresentException(type1, new NullPointerException());
        }
        ClassData class2 = classFinder.findClass(type2);
        if (class2 == null) {
            throw new TypeNotPresentException(type2, new NullPointerException());
        }
        if (class1.isAssignableFrom(class2)) {
            return type1;
        }
        if (class2.isAssignableFrom(class1)) {
            return type2;
        }
        if (class1.isInterface() || class2.isInterface()) {
            return "java/lang/Object";
        } else {
            do {
                class1 = classFinder.findClass(class1.getSuperName());
                if (class1 == null) {
                    throw new TypeNotPresentException(type1, new NullPointerException());
                }
            } while (!class1.isAssignableFrom(class2));
            return class1.getName().replace('.', '/');
        }
    }
}
